
В прошлом году я сидел на совещании со своими коллегами где нам рассказывал о Scala адин из ведущих  Scala адвокатов 
в Atlassian. Я слушал хорошие вещи о Scala, и так как я люблю пробывать новые вещи, я понял что хочу узнать, насколько клевой может быть Scala. К сожалению, я был разочарован. Большая часть уроков прошла мимо моей головы. Что самое ужасное, мои, казалось, понимали, о чем идет речь. Именно в этот день я понял несколько интересных вещей, о том как я учу что то новое. Я вспомнил, что был таким же в универе на лекциях. Я никогда не понимал, чему меня учили на лекциях. Вероятно поэтому, к концу универа я перестал посещять лекции. Это было до тех пор, пока я не столкнулся с реальной проблемой в лаборатории и мне надо было решать ее. Курсы о функциональных языках в универе не были самымы практичными, поэтому я и не узучал ФЯ. Вообще, я не думаю, что будет такой случай, что ФЯ будут иметь практическое значение для всего. Они учат таким вещам, как map, reduce, filter, fold, curried functions и так далее, и это выглядит как "Смотри, это то, о чем ты никогда не слышал!. Вот в чем его удивительность! Вот тривиальный математический пример не имеющий отношения к реальному миру! Посмотрите как его применить на практике!" 

Я завидую тем людям, которым легко дается такое обучение. Что касается меня, то мне нужно понимать проблему, которую надо решить, нежели чем изучать это ее. Так что если вы читаете это статью идумаете "Так это же я!", и вы хотите изучать Scala, то надеюсь это пост для вас. Я собираюсь начать с практичческой проблемы, котору я надеюсь вы поймете и захотите решить, и затем показать три особенности Scala позволяющие решить ее элегантно и просто. Надеюсь, после прочтения вы хорошо поймете эти особенности, и будете лучше читать склавкий код. 

### Проблема 
Проблема, которую я хочу решить это управние зависимостями. Если вы использовали Maven, вы знаете какой он перегруженный (многословный). Для тех, кто не работал с Maven, указание зависимости выглядит слудующим образом: 

    <dependency>
        <groupId>net.vz.mongodb.jackson</groupId>
        <artifactId>mongo-jackson-mapper</artifactId>
        <version>1.4.1</version>
    </dependency>
    
Другими словами, это зависимость артифакта `mongo-jackson-mapper` версии 1.4.1 от организации `net.vz.mongodb.jackson`. Обьяснение короче кода! Может быть, разработчики Maven могли бы сделать это лучше, уместив это в одну строчку, и это могло бы стать понятнее. Например: 

    <dependency>net.vz.mongodb.jackson:mongo-jackson-mapper:1.4.1</dependency>
    
Однако существуют некоторые преимущества у такой подробной модели - она может в полной мере выразить каждый элемент зависимости, но ничего не знает о зависимостях, прописанных в другом формате. Кроме того, есть другие отрибуты (scope или classifier) которые указывают дополнительные параметры, поэтому если уместить все в одну стороку то читать это будет невозможно. 

Так вот в чем проблема, я хочу некий DSL для того что бы прописывать короткие однозначные зависимости проекта. И я собираюсь использовать Scala. SBT, Simple Build Tool - инструмент написанный на Scala для указания конфигурации сборки проета и для управления зависимостями. И я хочу показать как управлять зависимостями используя SBT. К концу статьи Вы поймете как испозьвать этот инструмент в мире Scala. 

### Как же это сделать
Во первых, решение которое я покажу подразумевает, что вы знакомы со Scala ситнтаксисом и знаете что такое классы, поля, методы. Если Вы не знакомы с синтаксисом Scala, то вам вероятно следует ознакомиться с ним. 

    def groupId(groupId: String) = new GroupId(groupId)
    
    class GroupId(val groupId: String) {
        def artifact(artifactId: String) = new Artifact(groupId, artifactId)
    }
    
    class Artifact(val groupId: String, val artifactId: String) {
        def version(version: String) = new VersionedArtifact(groupId, artifactId, version)
    }
    
    class VersionedArtifact(val groupId: String, val artifactId: String, val version: String) {
    }

У нас есть три класса, `GroupId` у которого есть метод для создания `Artifact`, который имеет метод для создания `VersionedArtifact` который и описывает нашу зависимость. Также есть фабричный метод для создания группы. Чтобы использовать его:

    groupId("net.vz.mongodb.jackson")
        .artifact("mongo-jackson-mapper")
        .version("1.4.1")

Уже это выглятит лучше чем XML, но тоже самое можно сделать и на Java. Scala может предложить нечно больше. Но чтоит отметить, что все изменения кторые мы сделаем в процессе статьи будут делать ровно тоже самое что и описанные выше классы. 

###Урок 1: Названия методов Scala могут содержать UTF-8 символы
Есть несколько строгих правил о том, какое должно быть имя метода, но одно из них - имя может состоиять из одного символа оператора (+, *, /, %, -). Поэтому, первое изменение, которое мы соираемся сделать это избавиться от имен методов. Это сделает код более лаконичным. 

    def groupId(groupId: String) = new GroupId(groupId)
    
    class GroupId(val groupId: String) {
         def %(artifactId: String) = new Artifact(groupId, artifactId)
    }
    
    class Artifact(val groupId: String, val artifactId: String) {
        def %(version: String) = new VersionedArtifact(groupId, artifactId, version)
    }
    
    class VersionedArtifact(val groupId: String, val artifactId: String, val version: String) {
    }

И теперь, наш код будет выглядит следующим образом:

    groupId("net.vz.mongodb.jackson").%("mongo-jackson-mapper").%("1.4.1")
    
###Урок второй: Scala позволяет вызывать методы без точек или скобок
Опять таки, есть некоторые строгие ограничения но за ними я отправляю читателя в интернет. Одним словом, если метод имеет один параметр его можно вызвать без точек или скобок, просто заменив их пробелами. 

    groupId "net.vz.mongodb.jackson" % "mongo-jackson-mapper" % "1.4.1"
    
Это называется инфиксной нотацией, которую вы могли встретить в других языках. Решение уже выглядит более лаконичным, и мы все еще придерживаемся трогой типизации `VersionedArtifact` и однозначной зависимости артефакта. Но мы еще не закончили. 
 
###Урок третий: Scala позволяет конвертировать любой тип в любой неявным образом.
Для меня это была самая необычная фишка Scala, когда я впервые узнал оней. Она очень хороша и в тоже время опасна. 
В большинтве языков произойдет ошибка, когда вы вызываете несуществующий метод у обьекта. Для статически типизорованных языков это будет ошибка компиляции, для динамически типизорованных языков runtime error. Однако Scala не такая простая. Когда она не может найти метод у обьекта (во время компиляции, потому что Scala статически типизорованный язык), она не сразу бросает ошибку, а выполняет еще некоторые действия. 

У Scala есть неявные методы (и поля, но сейчас говорим только о методах). Когда метод, который вы вызываете не существует у обьекта, скала проверят текущий скоуп на наличие неявных методов, у которых аргумент такого же типа, что и ваш обьект (у которого вы вызываете метод). Если возвращаемым типом неявного метода является обьект, содержащий метод, который ВЫ хотите вызвать, то Scala оборачивает исходный обьект в вызов неявного метода. Я  потерял Вас, не так ли? Давайте посмотрим пример. 

    implicit def groupId(groupId: String) = new GroupId(groupId)

Все что я сделал, так это метод `groupId` теперь неявный. Теперь, когда я прописываю зависимость :  

    "net.vz.mongodb.jackson" % "mongo-jackson-mapper" % "1.4.1"

Обратите внимание, что метод `groupId` полностью изчез. Если такой ситаксис кажется вам ошеломляющим, давайте пойдем другим путем, сначала применим неявное преобразование, потом избавимся от скобок, и после сменим названия методов. 

    "net.vz.mongodb.jackson".artifact("mongo-jackson-mapper").version("1.4.1")
    
Это выглядит как будто `String` класс имеет метод `artifact`. Но мы знаем, что это не так и Scala компилятор знает что это не так. Когда компилятор обрабатывет эту строчку кода, он коворит "есть ли любое неявное преобразование с агруметом `String` и возвращающее обьет с методом `artifact`?". И компилятор находит `groupId` метод, который удовлетворяет этим критериям и преобразует эту строчку в: 

    groupId("net.vz.mongodb.jackson").artifact("mongo-jackson-mapper").version("1.4.1")
    
Когда я впервые услышал об этой фиче, я думал что это приводит к массе путаниц. Если использоать это безответсвенно, то конечно может. Но если использовать оккуратно, то можно получить очень много возможностей, на пример, для написания DSL, как показанно выше, или для добавления методов в утаревшие методы.

Между делом, Scala использует такие фишки для добавления функциональных методоа в Java collections API, предоставляя коллекции. Путаница может возниктуть тогда, когда вы импортируте не те неявные преобразования  не в том месте кода. 
Scala позволяет вам писать `import` в любой части кода, поэтому если вы хотите один метод в классе который нжен для работы с Java коллекциями, Вы можете импортировать неявное преобразование чисто в этот блок кода. 

###Добавлние зависимости
Осталась послденая часть, которая покажет что мы можем делать с тем что мы написали. В SBT проекте есть файл `build.sbt` который содержит фрагменты кода на Scala, которые определяют конфигурация проекта. Например, переменная  `libraryDependencies`  содержит конфигурацию зависимостей. Поэтому, добавление зависимости в мой SBT проект сводиться к добавлению строчки кода в файл `build.sbt`: 

    libraryDependencies += "net.vz.mongodb.jackson" % "mongo-jackson-mapper" % "1.4.1"
    
Вы можете заметить здеть еще один инфиксный оператор  `+=`  метод определнный в mutable коллекциях для добавления элементов. Добавление нескольких зависимостей будет выглядеть так: 
   
    libraryDependencies ++= Seq(
        "net.vz.mongodb.jackson" % "mongo-jackson-mapper" % "1.4.1",
        "net.vz.mongodb.jackson" % "play-mongo-jackson-mapper" % "1.0.0"
    )

Как то так.  У нас очень немногословный способ указания зависимостей, строго типизированный, и проверяющийся время компиляции.
